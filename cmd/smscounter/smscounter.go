// SPDX-License-Identifier: MIT
//
// Copyright Â© 2019 Kent Gibson <warthog618@gmail.com>.

// smscounter provides an example of generating output similar to that
// generated by github.com/danxexe/sms-counter.
//
// This is non-optimal as it encodes the required Submit TPDUs, and calculates
// the output from them rather than just performing the minimal calculations
// required for the output. OTOH CPU is cheap so I've not bothered to add
// suitably optimised methods to the library. YMMV.
package main

import (
	"flag"
	"fmt"
	"log"
	"os"

	"github.com/shifty21/sms"
	"github.com/shifty21/sms/encoding/tpdu"
)

func main() {
	var msg string
	var nli int
	flag.StringVar(&msg, "message", "", "The message to encode")
	flag.IntVar(&nli, "language", 0, "The NLI of a character set to use in addition to the default")
	flag.Usage = usage
	flag.Parse()
	if msg == "" {
		flag.Usage()
		os.Exit(1)
	}
	c, err := NewCount(msg, nli)
	if err != nil {
		log.Fatalln(err)
	}
	fmt.Print(c)
}

// NewCount creates the SMS count statistics for a message.
func NewCount(msg string, nli int) (Count, error) {
	options := []sms.EncoderOption(nil)
	if nli != 0 {
		options = append(options, sms.WithCharset(nli))
	}
	c := Count{}
	pdus, err := sms.Encode([]byte(msg), options...)
	if err != nil {
		return c, err
	}
	alpha, _ := pdus[0].Alphabet()
	lastLen := len(pdus[len(pdus)-1].UD) // valid for 7bit as it is unpacked into octets.
	pm := pdus[0].UDBlockSize()
	switch alpha {
	case tpdu.Alpha7Bit:
		if hasEscapes(pdus) {
			c.Encoding = "7BIT_EX"
		} else {
			c.Encoding = "7BIT"
		}
	case tpdu.Alpha8Bit:
		c.Encoding = "8BIT"
	case tpdu.AlphaUCS2:
		c.Encoding = "UCS-2"
		lastLen /= 2 // UCS-2 code points
		pm /= 2      // UCS-2 code points
	}
	c.Pdulen = pm
	c.Llen = lastLen
	c.Remaining = c.Pdulen - c.Llen
	c.Messages = len(pdus)
	c.Tlen = (pm * (c.Messages - 1)) + lastLen
	return c, nil
}

func hasEscapes(pdus []tpdu.TPDU) bool {
	for _, pdu := range pdus {
		for _, d := range pdu.UD {
			if d == 0x1b {
				return true
			}
		}
	}
	return false
}

func usage() {
	fmt.Fprintf(os.Stderr, "smscounter determimes the number of SMS-Submit TPDUs "+
		"required to encode a given message.\n"+
		"The message is encoded using the GSM7 default alphabet, or if necessary\n"+
		"an optionally specified character set, or failing those as UCS-2.\n"+
		"If the message is too long for a single PDU then it is split into several.\n\n"+
		"Usage: smscounter -message <message>\n")
	flag.PrintDefaults()
}

// Count contains the statistics related to encoding a message in SMS-SUBMIT TPDUs.
type Count struct {
	Encoding  string
	Messages  int
	Tlen      int
	Llen      int
	Pdulen    int
	Remaining int
}

func (c Count) String() string {
	return fmt.Sprintf("encoding: %s\n", c.Encoding) +
		fmt.Sprintf("messages: %d\n", c.Messages) +
		fmt.Sprintf("total length: %d\n", c.Tlen) +
		fmt.Sprintf("last PDU length: %d\n", c.Llen) +
		fmt.Sprintf("per_message: %d\n", c.Pdulen) +
		fmt.Sprintf("remaining: %d\n", c.Remaining)
}
